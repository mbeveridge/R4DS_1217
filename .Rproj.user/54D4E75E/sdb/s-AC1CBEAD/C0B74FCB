{
    "collab_server" : "",
    "contents" : "---\ntitle: \"Chapter03\"\noutput:\n  github_document: default\n  html_notebook: default\n---\n\n```{r}\nlibrary(tidyverse)\n```\n\n\n## 3. \"Data visualisation\" [Chapter 1 hardcopy]\n### 3.2.4 Exercises\n\nQ1. Run `ggplot(data = mpg)`. What do you see?\n\nA1.\n```{r}\nggplot(data = mpg)\n```\nGrey background. No axes or data visible\n\n-----------\n\nQ2. How many rows are in `mpg`? How many columns?\n\nA2.\n```{r}\nmpg\n```\n234 rows x 11 columns\n\n-----------\n\nQ3. What does the `drv` variable describe? Read the help for `?mpg` to find out\n\nA3.\n```{r}\n?mpg\n```\n`f` = front-wheel drive, `r` = rear wheel drive, `4` = 4wd\n\n-----------\n\nQ4. Make a scatterplot of `hwy` vs `cyl` ...[ie. y v's x]\n\nA4.\n```{r}\nggplot(data = mpg) +\n  geom_point(mapping = aes(x = cyl, y = hwy))\n```\n\n-----------\n\nQ5. What happens if you make a scatterplot of `class` vs `drv`? Why is the plot not useful?\n\nA5.\n```{r}\nggplot(data = mpg) +\n  geom_point(mapping = aes(x = drv, y = class))\n```\nThe plot has 2 categorical variables, (but shows no dependency), with an unknown number of points at many intersections (ie. overlap)\n\n\n-----------\n\n## 3. \"Data visualisation\" [Chapter 1 hardcopy]\n### 3.3.1 Exercises\n\nQ1. What’s gone wrong with this code? Why are the points not blue?\n```{r}\nggplot(data = mpg) +\n  geom_point(mapping = aes(x = displ, y = hwy, color = \"blue\"))\n```\n\nA1. Needs to be outside the `aes()` to work like that. (Inside, it just creates a 'True' condition, but with no say over what colour represents it in the plot)\n\n-----------\n\nQ2. Which variables in `mpg` are categorical? Which variables are continuous? (Hint: type `?mpg` to read the documentation for the dataset). How can you see this information when you run `mpg`?\n\nA2.\n```{r}\n?mpg\nmpg\n```\n* Categorical : `<chr>` : `manufacturer`; `model`; `trans`; `drv`; `fl`; `class` ...6\n* Continuous : `<dbl>` or `<int>` : `displ`; `year`; `cyl`; `cty`; `hwy` ...5\n\n-----------\n\nQ3.\nMap a continuous variable to `color`, `size`, and `shape` ...[I initially misunderstood the requirement, and mapped them all in one plot]\nHow do these aesthetics behave differently for categorical vs. continuous variables? ...[eg. `drv` `<chr>`; `cty` `<int>`]\n\nA3.\n```{r}\nggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, color = drv))\nggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, size = drv))\nggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, shape = drv))\n```\n\n```{r}\nggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, color = cty))\nggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, size = cty))\n```\n`ggplot(data = mpg) + geom_point(mapping = aes(x = displ, y = hwy, shape = cty))` # \"Error: A continuous variable cannot be mapped to shape\"\"\n\nANSWER [categorical v's continuous] :\n\n* `color` : different hues v's tints & shades of a single hue\n* `size` : allocation of size to variable is arbitrary (warning) v's relates to size of variable\n* `shape` : allocation of shape to variable is arbitrary v's error (as 'meaningless')\n\n-----------\n\nQ4. What happens if you map the same variable to multiple aesthetics?\n\nA4.\n```{r}\nggplot(data = mpg) +\n  geom_point(mapping = aes(x = displ, y = hwy, color = displ, size = hwy))\n```\nThe plot does use all the aesthetics. But there is redundancy, which may be confusing (as a reader expects that an aesthetic is added for extra insight)\n\n-----------\n\nQ5. What does the `stroke` aesthetic do? What shapes does it work with? (Hint: use `?geom_point`)\n\nA5.\n```{r}\n?geom_point\nggplot(data = mpg) +\n  geom_point(mapping = aes(x = displ, y = hwy), shape = 21, colour = \"black\", fill = \"white\", size = 5, stroke = 5)\n```\n\"For shapes that have a border (like 21), you can colour the inside and outside separately. Use the `stroke` aesthetic to modify the width of the border\"\n\n-----------\n\nQ6. What happens if you map an aesthetic to something other than a variable name, like `aes(colour = displ < 5)` ?\n\nA6.\n```{r}\nggplot(data = mpg) +\n  geom_point(mapping = aes(x = displ, y = hwy, color = displ < 5))\n```\nExpression is True/False for each point, splitting `displ` into 2 sets with different colours ...(Remember Q1 with `color = \"blue\"`)\n\n\n-----------\n\n## 3. \"Data visualisation\" [Chapter 1 hardcopy]\n### 3.5.1 Exercises\n\nQ1. What happens if you facet on a continuous variable?\n\nA1.\n```{r}\nggplot(data = mpg) +\n  geom_point(mapping = aes(x = drv, y = cyl)) +\n  facet_wrap(~ displ)\n```\nA cell is created for every value of the continuous variable. (Unlikely to be the most insightful choice)\n\n-----------\n\nQ2. What do the empty cells in plot with `facet_grid(drv ~ cyl)` mean? How do they relate to this plot?\n```{r}\nggplot(data = mpg) +\n  geom_point(mapping = aes(x = drv, y = cyl))\n\nggplot(data = mpg) +\n  geom_point(mapping = aes(x = drv, y = cyl)) +\n  facet_grid(drv ~ cyl)\n```\n\nA2.\n\n* 1st plot maps combinations of 2 categorical variables. No point at an intersection means the data doesn't contain that combination\n* 2nd plot has an empty cell when 'the data doesn't contain that combination'\n\n-----------\n\nQ3. What plots does the following code make? What does `.` do?\n```{r}\nggplot(data = mpg) +\n  geom_point(mapping = aes(x = displ, y = hwy)) +\n  facet_grid(drv ~ .)\n\nggplot(data = mpg) +\n  geom_point(mapping = aes(x = displ, y = hwy)) +\n  facet_grid(. ~ cyl)\n```\n\nA3.\n\n* 1st plot has long horizontal cells (3 rows, no cols)\n* 2nd plot has tall vertical cells (0 rows, 4 cols)\n* `.` acts as a placeholder in the script (when facet_grid is missing a variable), and causes no faceting in that dimension\n\n-----------\n\nQ4.\nTake the first faceted plot in this section:\n```{r}\nggplot(data = mpg) +\n  geom_point(mapping = aes(x = displ, y = hwy)) +\n  facet_wrap(~ class, nrow = 2)\n\nggplot(data = mpg) +\n  geom_point(mapping = aes(x = displ, y = hwy, colour = class))\n```\nWhat are the advantages to using faceting instead of the colour aesthetic? What are the disadvantages?\nHow might the balance change if you had a larger dataset?\n\nA4.\n\n* Adv : reduces qty of points in a cell, so less overlapping and easier to spot different trends\n* Disadv : harder to judge location of points in a cell relative to other cells (ie. overall picture). Squeezes the size of a cell\n* Larger dataset has more overlapping, unless faceting used. (Though if the categorical variables used for faceting have many values, the cells will be tiny)\n\n-----------\n\nQ5. \nRead `?facet_wrap`. What does `nrow` do? What does `ncol` do?\nWhat other options control the layout of the individual panels?\nWhy doesn’t `facet_grid()` have `nrow` and `ncol` argument?\n\nA5.\n```{r}\n?facet_wrap\n```\n\"`facet_wrap` wraps a 1d sequence of panels into 2d. This is generally a better use of screen space than `facet_grid` because most displays are roughly rectangular\" -- Help\n\n* `nrow` breaks a single row of cells into the specified number of rows. Similarly `ncol` specifies number of cols to have in the plot\n* `as.table` [= TRUE or FALSE] determines the starting facet to begin filling the plot. And `dir` [= \"h\" or \"v\"] determines the starting direction for filling in the plot\n* `facet_grid()` has its x and y dimensions determined by its arguments (number of unique values of the 2 variables)\n\n-----------\n\nQ6. When using `facet_grid()` you should usually put the variable with more unique levels in the columns. Why?\n\nA6. PC displays are usually landscape format, so a reader can distinguish many columns more easily than many rows (and dependent variable is usually y-axis)\n\n\n-----------\n\n## 3. \"Data visualisation\" [Chapter 1 hardcopy]\n### 3.6.1 Exercises\n\nQ1. What geom would you use to draw a line chart? A boxplot? A histogram? An area chart?\n\nA1. `geom_line()`, `geom_boxplot()`, `geom_histogram()`, `geom_area()`\n\n-----------\n\nQ2. Run this code in your head and predict what the output will look like. Then, run the code in R and check your predictions:\n```{r}\nggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = drv)) +\n  geom_point() +\n  geom_smooth(se = FALSE)\n```\n\nA2. Ok\n\n-----------\n\nQ3.\nWhat does `show.legend = FALSE` do? What happens if you remove it?\nWhy do you think I used it earlier in the chapter?\n\nA3.\n```{r}\nggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = drv)) +\n  geom_point(show.legend = FALSE) +\n  geom_smooth(show.legend = FALSE, se = FALSE)\n```\n\n* Plot does not have a legend. Removing 'FALSE' will add a legend (because default is 'TRUE')\n* 'FALSE' used earlier, to 'expand' the size/proportion of the plot used by data\n\n-----------\n\nQ4.What does the `se` argument to `geom_smooth()` do?\n\nA4.\n```{r}\n?geom_smooth\n```\n\"display confidence interval around smooth? (TRUE by default, see level to control\" ...ie. It adds error bands to a line\n\n-----------\n\nQ5. Will these two graphs look different? Why/why not?\n```{r}\nggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = drv)) +\n  geom_point() +\n  geom_smooth()\n\nggplot() +\n  geom_point(data = mpg, mapping = aes(x = displ, y = hwy, color = drv)) +\n  geom_smooth(data = mpg, mapping = aes(x = displ, y = hwy, color = drv))\n```\n\nA5.\nThey will look the same, because the data & mapping settings are the same in each.\n(The settings cascade down ...ie. are inherited, but are superceded by local settings)\n\n-----------\n\nQ6. Recreate the R code necessary to generate the following graphs.\n\nA6.1\n```{r}\nggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +\n  geom_point() +\n  geom_smooth(color = \"blue\", se = FALSE)\n```\n\n\nA6.2\n```{r}\nggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +\n  geom_point() +\n  geom_smooth(mapping = aes(group = drv), color = \"blue\", se = FALSE)\n```\n\n\nA6.3\n```{r}\nggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = drv)) +\n  geom_point() +\n  geom_smooth(se = FALSE)\n```\n\n\nA6.4\n```{r}\nggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +\n  geom_point(mapping = aes(color = drv)) +\n  geom_smooth(se = FALSE)\n```\n\n\nA6.5\n```{r}\nggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +\n  geom_point(mapping = aes(color = drv)) +\n  geom_smooth(mapping = aes(linetype = drv), se = FALSE)\n```\n\n\nA6.6\n```{r}\nggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +\n  geom_point(color = \"white\", stroke = 2) +\n  geom_point(mapping = aes(color = drv))\n```\n* Note the white points are in the earlier layer, with the coloured points then on top\n* Instead of `stroke=2` could have used `size=4` (from seeing someone else's answer)\n* Actually, why did `stroke` work? - does it not need to be with a shapetype that can have color+fill? (re. 3.3.1 Exercises Q5 and its border)\n\n\n-----------\n\n## 3. \"Data visualisation\" [Chapter 1 hardcopy]\n### 3.7.1 Exercises\n\nQ1.\nWhat is the default geom associated with `stat_summary()`?\nHow could you rewrite the previous plot to use that geom function instead of the stat function?\n\nA1.\n```{r}\n?stat_summary\n?geom_pointrange\n\n# 'previous plot' in the book text, before 3.7.1 Exercises :\nggplot(data = diamonds) +\n  stat_summary(mapping = aes(x = cut, y = depth), fun.ymin = min, fun.ymax = max, fun.y = median)\n```\n\nDefault geom for `stat_summary` is `geom_pointrange`. But default stat for `geom_pointrange` is `identity` (which is NOT what we want), so explicitly specify `geom_pointrange(stat = \"summary\")` [see below] :\n```{r}\nggplot(data = diamonds) +\n  geom_pointrange(mapping = aes(x = cut, y = depth), stat = \"summary\", fun.ymin = min, fun.ymax = max, fun.y = median)\n```\n\n-----------\n\nQ2. What does `geom_col()` do? How is it different to `geom_bar()`?\n\nA2.\n```{r}\n?geom_col\n?geom_bar\n```\n\n* \"`geom_bar` uses `stat_count` by default: it counts the number of cases at each x position.\n* `geom_col` uses `stat_identity`: it leaves the data as is\" -- Help\n* [However, `geom_bar(stat = \"identity\")` and `geom_col()` are equivalent]\n\n-----------\n\nQ3.\nMost geoms and stats come in pairs that are almost always used in concert.\nRead through the documentation and make a list of all the pairs. What do they have in common?\n\nA3.\nhttp://ggplot2.tidyverse.org/reference/ [lists lots of pairs, after this quote] :\n\"A layer combines data, aesthetic mapping, a geom (geometric object), a stat (statistical transformation), and a position adjustment. Typically, you will create layers using a geom_ function, overriding the default position and stat if needed\"\n\n?\n\n-----------\n\nQ4. What variables does `stat_smooth()` compute? What parameters control its behaviour?\n\nA4.\n```{r}\n?stat_smooth\n```\n* Four : `y` [predicted value]; `ymin` [lower pointwise confidence interval around the mean]; `ymax` [upper pointwise confidence interval around the mean]; `se` [standard error]\n* Most importantly : `method` [smoothing method (function) to use]; `se` [whether to display confidence interval (TRUE default)]; `level` [level of confidence interval to use (0.95 default)]\n\n-----------\n\nQ5.\nIn our proportion bar chart, we need to set `group = 1`. Why?\nIn other words what is the problem with these two graphs?\n```{r}\nggplot(data = diamonds) +\n  geom_bar(mapping = aes(x = cut, y = ..prop..)) # 'prop' is 1.00 for each value of 'cut'\n\nggplot(data = diamonds) +\n  geom_bar(mapping = aes(x = cut, fill = color, y = ..prop..)) # 'prop' is 7 for each value of 'cut' (7 colors)\n```\n\nA5.\nWe've relied on other variables to change aggregation (eg. `color = drv` instead of a separate `group = drv`)\ncf. s3.6 : \"It is convenient to rely on this feature because the group aesthetic by itself does not add a legend or distinguishing features to the geoms\".\n\nBut `..prop..` means proportion of group, and that will be 100% unless we force it otherwise.\n`group=1` means everything is in the same group (named '1'), rather than in different groups (named Fair, Good, etc ...if group=cut) ...Imagine a field called 'group', where every row has the value '1' there.\ngroup=2 or group=X would have the same effect. [?? Don't know why it has to be inside aes(), since it's a constant ??]\n```{r}\nggplot(data = diamonds) +\n  geom_bar(mapping = aes(x = cut, y = ..prop.., group = 1))\n\nggplot(data = diamonds) +\n  geom_bar(mapping = aes(x = cut, fill = color, y = ..prop.., group = 1)) # Note : chart isn't coloured, and displays same as the one above\n\nggplot(data = diamonds) +\n  geom_bar(mapping = aes(x = cut, fill = color, y = ..prop.., group = 1)) +\n  facet_wrap(~ color)\n```\n\n\n-----------\n\n## 3. \"Data visualisation\" [Chapter 1 hardcopy]\n### 3.8.1 Exercises\n  \nQ1. What is the problem with this plot? How could you improve it?\n```{r}\nggplot(data = mpg, mapping = aes(x = cty, y = hwy)) +\n  geom_point()\n```\n\nA1.\n\n* Many of the data points overlap (overplotting).\n* We can 'jitter' the position of points, to improve the overall visualization (in this case)\n```{r}\nggplot(data = mpg, mapping = aes(x = cty, y = hwy)) +\n  geom_jitter()\n```\n\n-----------\n\nQ2. What parameters to `geom_jitter()` control the amount of jittering?\n\nA2.\n```{r}\n?geom_jitter\n```\n`width` and `height`...\n\n\"Amount of vertical and horizontal jitter. The jitter is added in both positive and negative directions, so the total spread is twice the value specified here.\n\nIf omitted, defaults to 40% of the resolution of the data: this means the jitter values will occupy 80% of the implied bins. Categorical data is aligned on the integers, so a width or height of 0.5 will spread the data so it's not possible to see the distinction between the categories\" -- Help\n\n-----------\n\nQ3. Compare and contrast `geom_jitter()` with `geom_count()`\n\nA3.\n```{r}\n?geom_count\n\nggplot(data = mpg, mapping = aes(x = cty, y = hwy)) +\n  geom_count()\n```\n\"This is a variant `geom_point` that counts the number of observations at each location, then maps the count to point area\".\n\n`geom_count()` makes larger points where there is overplotting, so the number of visible points is equal to `geom_point()`. (Whether to use this or `geom_jitter` will vary with circumstances and personal preference)\n\n-----------\n\nQ4.\nWhat’s the default position adjustment for `geom_boxplot()`?\nCreate a visualisation of the `mpg` dataset that demonstrates it\n\nA4.\n```{r}\n?geom_boxplot\n```\n`position = \"dodge\"` is the default. (cf. fill, identity, jitter, stack)\n\n```{r}\nggplot(data = mpg, mapping = aes(x = class, y = hwy, color = drv)) +\n  geom_boxplot(position = \"dodge\")\n```\n\n\n-----------\n\n## 3. \"Data visualisation\" [Chapter 1 hardcopy]\n### 3.9.1 Exercises\n\nQ1. Turn a stacked bar chart into a pie chart using `coord_polar()`\n\nA1.\n```{r}\n?coord_polar # A pie chart = stacked bar chart + polar coordinates\n# pie <- ggplot(mtcars, aes(x = factor(1), fill = factor(cyl))) +\n#  geom_bar(width = 1)\n# pie + coord_polar(theta = \"y\")\n```\n\n```{r}\nggplot(data = mpg, mapping = (aes(x = 1, fill = class))) + # Need x. x=1 gave a single stack, centred on '1'. x=factor(1) would get rid of extra scaling marks\n  geom_bar(position = \"stack\")\n```\n\n```{r}\nggplot(data = mpg, mapping = (aes(x = 1, fill = class))) + # x=factor(1) would get rid of extra scaling marks\n  geom_bar(position = \"stack\") +\n  coord_polar(theta = \"y\") # theta=\"y\" gave pie segments, (instead of rings, if theta=\"x\" or left blank)\n```\n\n-----------\n\nQ2. What does `labs()` do? Read the documentation\n\nA2.\n```{r}\n?labs\n```\n`labs()` is a shortcut function to add labels to different scales ...title, subtitle, axes, and caption\n\n-----------\n\nQ3. What’s the difference between `coord_quickmap()` and `coord_map()`?\n\nA3.\n```{r}\n?coord_map\n```\n* \"`coord_quickmap()` sets the aspect ratio correctly for maps\" -- R4DS text\n* \"`coord_map` projects a portion of the earth, which is approximately spherical, onto a flat 2D plane\nusing any projection defined by the `mapproj` package. Map projections do not, in general, preserve\nstraight lines, so this requires considerable computation. `coord_quickmap` is a quick approximation\nthat does preserve straight lines. It works best for smaller areas closer to the equator\" -- Help\n\n-----------\n\nQ4. What does the plot below tell you about the relationship between city and highway mpg?\nWhy is `coord_fixed()` important? What does `geom_abline()` do?\n```{r}\nggplot(data = mpg, mapping = aes(x = cty, y = hwy)) +\n  geom_point() +\n  geom_abline() +\n  coord_fixed()\n```\n\nA4.\nRelationship is positive and approximately linear. Slightly better highway mpg than city mpg\n\n* `coord_fixed()` draws equal intervals on \\(x\\) & \\(y\\) axes, so more easily comparable (`abline` is at 45 degrees)\n* `geom_abline()` draws a line that, by default, has an intercept of 0 and slope of 1\n\n\n-----------\n\n_Comment & code from @aaron_g in (R4DS Slack) board=02_week on 15/9/17 06:25, in reply to query from @darh78.\nNot one of the exercises, but saved here in case useful in future. (Slope charts in a lattice) :_\n\n_\"i think this kind of graph is much more informative (maybe this is what you had in mind to begin with)\"_\n```{r}\nmpg1 <- mpg %>% \n  mutate(unique = rownames(mpg)) %>%\n  gather(\"road_type\" ,\"MPG\", c(\"cty\", \"hwy\"))\n\nggplot(data = mpg1,mapping = aes(x = road_type, y = MPG, color=drv ,group=unique)) +\n  geom_point() +\n  facet_wrap(~manufacturer, nrow=3)+\n  geom_line(alpha=0.5) +\n  theme_linedraw(base_size = 14)\n```\n\n",
    "created" : 1515619036099.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4269803210",
    "id" : "C0B74FCB",
    "lastKnownWriteTime" : 1516787927,
    "last_content_update" : 1516901966758,
    "path" : "~/Dropbox/repos/R4DS_1217/R4DS_Chapter03.Rmd",
    "project_path" : "R4DS_Chapter03.Rmd",
    "properties" : {
        "chunk_output_type" : "inline",
        "tempName" : "Untitled3"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}