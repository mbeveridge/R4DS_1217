{
    "collab_server" : "",
    "contents" : "---\ntitle: \"Chapter12\"\noutput:\n  github_document: default\n  html_notebook: default\n---\n\n```{r}\nlibrary(tidyverse)\n```\n\n\n## 12. \"Tidy data\" [Chapter 9 hardcopy]\n### 12.2.1 Exercises\n\nQ1. Using prose, describe how the variables and observations are organised in each of the sample tables.\n\nA1.\n```{r}\n?table1\n```\n\ns12.2 \"Tidy data\" :\n\"Each dataset shows the same values of four variables `country`, `year`, `population`, and `cases`, but each dataset organises the values in a different way\" :\n\n* `table1`:     TIDY: Each variable has its own column. Each observation has its own row. (By `country`, by `year`)\n* `table2`: NOT TIDY: 2 rows per observation : `cases` & `population` are rows in `type` column, instead of being their own cols\n* `table3`: NOT TIDY: `cases` & `population` are combined in `rate` column, instead of having their own cols, (so each value doesn't have its own cell, either)\n* `table4`: NOT TIDY: 2 observations per row : `1999` & `2000` are cols, instead of being in a `year` column. (There are actually 2 tables, for `cases` & `population` ...`table4a` & `table4b`)\n\n-----------\n\nQ2.\nCompute the `rate` for `table2`, and `table4a` + `table4b`. You will need to perform four operations:\n\n1. Extract the number of TB cases per country per year       # cases\n2. Extract the matching population per country per year      # population\n3. Divide cases by population, and multiply by 10000         # rate\n4. Store back in the appropriate place\nWhich representation is easiest to work with? Which is hardest? Why?\n\nA2.\nSome notes, from previous chapters, about where we met the `filter()` and `$` used below (for TABLE2 and TABLE4) :\n\n* [s5.2 Filter rows with `filter()`] : \"`filter()` allows you to subset observations based on their values\"\n* [s5.4 Select columns with `select()`] : \"`select()` allows you to rapidly zoom in on a useful subset\"\n* [s10.3.2 Subsetting] : \"If you want to pull out a single variable, you need some new tools, `$` and `[[`\"\n* [s10.4 Interacting with older code] : \"We don’t use `[` much in this book because `dplyr::filter()` and `dplyr::select()` allow you to solve the same problems with clearer code\"\n\n\nTABLE2 failed attempt - thinking it would be easy :\n```{r}\ncases <- table2 %>% filter(type == \"cases\")                  # 1.\npopulation <- table2 %>% filter(type == \"population\")        # 2.\nrate <- cases / population                                   # 3.\n# FAIL : \"Error in FUN(left, right) : non-numeric argument to binary operator\"\n```\n\nTABLE2 building a tibble up from pieces. Assumes initial 4 rows for each country, all sorted :\n```{r}\ncases <- filter(table2, type == \"cases\")$count               # 1. ...This time, take only the relevant column\npopulation <- filter(table2, type == \"population\")$count     # 2. ...This time, take only the relevant column\ncountry <- filter(table2, type == \"cases\")$country           #    ...`filter()` by one `type`, either one\nyear <- filter(table2, type == \"cases\")$year                 #    ...`filter()` by one `type`, either one\ntable2_new <- tibble(country = country,\n                        year = year,\n                       cases = cases,\n                  population = population,\n                        rate = cases / population * 10000)   # 3., 4. ...`rate` to answer the Q; rest for future use\ntable2_new                                                   # [s12.3.2 R4DS book will show tidy via `spread()`]\n```\n\n\nTABLE4 building a tibble up from pieces. Assumes `table4a` & `table4b` are the same length, and sorted in the same order :\n```{r}\ntable4_new <- tibble(country = table4a$country,              #    ...`country` from one table, either one\n       `1999` = table4a$`1999` / table4b$`1999` * 10000,     # 3.\n       `2000` = table4a$`2000` / table4b$`2000` * 10000)     # 3., 4. ...`rate` answers the Q. But no tidy dataset\ntable4_new                                                   # [s12.3.1 R4DS book will show tidy via `gather()`]\n```\n\n\n`table1` is the easiest representation to work with (as seen in s12.2). (It is TIDY.) Doesn't need filtering and `rate` just adds another column to existing tibble :\n```{r}\ntable1 %>% \n  mutate(rate = cases / population * 10000)                  # 3.,4.\n```\n\n-----------\n\nQ3. Recreate the plot showing change in cases over time using `table2` instead of `table1`. What do you need to do first?\n\nA3.\n[Question is referring to an example at the end of s12.2, that used `table1`]\nReplacing `table1` with `table2_new` in the code. (No other changes made) :\n```{r}\n# Compute cases per year\ntable2_new %>% \n  count(year, wt = cases)\n# Visualise changes over time\n  ggplot(table2_new, aes(year, cases)) + \n  geom_line(aes(group = country), colour = \"grey50\") + \n  geom_point(aes(colour = country))\n```\nThis gave the same results as with `table1` (which is same data, so ok). But it seems too easy, (and the first 2 lines aren't even needed for the plot), so probably not what the Q meant\n\nTrying again, starting with `table2` (not `table2_new`). So can't simply use `aes(year, cases)`. Need to filter to use just the `cases` rows, and use `count` column on the y-axis :\n```{r}\ntable2 %>% \n  filter(type == \"cases\") %>%\n  ggplot(aes(year, count)) + \n  geom_line(aes(group = country), colour = \"grey50\") +          # same as before\n  geom_point(aes(colour = country))                             # same as before\n```\n\n\n-----------\n\n## 12. \"Tidy data\" [Chapter 9 hardcopy]\n### 12.3.3 Exercises\n\nQ1.\nWhy are `gather()` and `spread()` not perfectly symmetrical?\nCarefully consider the following example:\n```{r}\nstocks <- tibble(\n  year   = c(2015, 2015, 2016, 2016),\n  half  = c(   1,    2,     1,    2),\n  return = c(1.88, 0.59, 0.92, 0.17)\n)\nstocks %>% \n  spread(year, return) %>% \n  gather(\"year\", \"return\", `2015`:`2016`)\n# key = \"year\", value = \"cases\" ...and columns to gather are at the end (v's at start, in s12.3 teaching)\n```\n(Hint: look at the variable types and think about column _names_.)\n\nBoth `spread()` and `gather()` have a `convert` argument. What does it do?\n\nA1.\nThe `stocks` tibble is created with 3 columns : `year`, `half`, `return`. Doing `spread()` [displays `half`, `2015`, `2016` columns] and then `gather()` [displays `half`, `year`, `return`] one may expect to return ('symmetrical') to the original tibble ...but `year` began as type `<dbl>` and is now of type `<chr>` ...(And column order differs)\n\n'Why?' : `gather()` will convert numeric variable names to strings ...(And columns not involved in the spread/gather 'move left')\n\n```{r}\n?spread\n?gather\n```\n\nRepeating, but this time with a `convert` argument :\n```{r}\nstocks %>% \n  spread(year, return) %>%\n  gather(\"year\", \"return\", `2015`:`2016`, convert = TRUE)\n```\n`convert=TRUE` will change a variable's class from `<chr>` to numeric/integer/logical, if it was that before the `gather()`.\n(Doesn't work for factor or date.) 'Help' reads similarly for `spread()`, but I think its use is more nuanced/complicated\n...\"Use `convert = TRUE` to produce variables of mixed type\".\nIn example above `year` ends up converted to `<int>`. (It started as `<dbl>`, and would have become `<chr>`)\n\n-----------\n\nQ2.\nWhy does this code fail? :\n```{r}\ntable4a %>% \n  gather(1999, 2000, key = \"year\", value = \"cases\")\n```\n\nA2.\n\"Error in `inds_combine(.vars, ind_list)` : Position must be between 0 and n\" -- error message\n\n* \"Note that “1999” and “2000” are non-syntactic names (because they don’t start with a letter) so we have to surround them in backticks\" -- s12.3.1 R4DS book\n* \"The tidyverse functions will interpret `1999` and `2000` without quotes as looking for the 1999th and 2000th column of the data frame\" -- https://jrnold.github.io/r4ds-exercise-solutions/tidy-data.html#spreading-and-gathering\n\n-----------\n\nQ3.\nWhy does spreading this tibble fail? How could you add a new column to fix the problem? :\n```{r}\npeople <- tribble(\n  ~name,             ~key,    ~value,\n  #-----------------|--------|------\n  \"Phillip Woods\",   \"age\",       45,\n  \"Phillip Woods\",   \"height\",   186,\n  \"Phillip Woods\",   \"age\",       50,\n  \"Jessica Cordero\", \"age\",       37,\n  \"Jessica Cordero\", \"height\",   156\n)\n```\n\nA3.\n```{r}\npeople\nspread(people, key = key, value = value)\n```\n\"Error: Duplicate identifiers for rows (1, 3)\" -- error message\n\n* `Spread` fails because rows 1 & 3 both have “age” for “Phillip Woods”\n* To fix this, could add a new column, where rows 1 & 3 have different values for a new categorical variable (eg. person who collected the data?), to distinguish them\n* In this example (after fixing), the spread tibble will have `NA` for `height` in one row\n\n-----------\n\nQ4.\nTidy the simple tibble below. Do you need to spread or gather it? What are the variables? :\n```{r}\npreg <- tribble(\n  ~pregnant, ~male, ~female,\n  \"yes\",     NA,    10,\n  \"no\",      20,    12\n)\n```\n\nA4.\nThe variables are (`pregnant` and) `sex` and `count`. Need to `gather` it. (`key = \"sex\"` and `value = \"count\"`) :\n```{r}\npreg %>%\n  gather(male, female, key = \"sex\", value = \"count\")\n# I assume `count` is `baby_qty`, but safer to leave as `count`\n```\n\n\n-----------\n\n## 12. \"Tidy data\" [Chapter 9 hardcopy]\n### 12.4.3 Exercises\n\nQ1.\nWhat do the `extra` and `fill` arguments do in `separate()`?\n\nExperiment with the various options for the following two toy datasets :\n```{r}\ntibble(x = c(\"a,b,c\", \"d,e,f,g\", \"h,i,j\")) %>% \n  separate(x, c(\"one\", \"two\", \"three\"))          # \"Warning message: Too many values at 1 locations: 2\". 3x3 tibble\n\ntibble(x = c(\"a,b,c\", \"d,e\", \"f,g,i\")) %>% \n  separate(x, c(\"one\", \"two\", \"three\"))          # \"Warning message: Too few values at 1 locations: 2\". 3x3 tibble\n```\n\nA1.\n```{r}\n?tibble\n?separate\n```\n\n`extra` : controls what happens when there are too many pieces [as in 1st dataset]. Three valid options :\n\n* `warn` (the default): emit a warning and drop extra values. # As seen above\n* `drop`: drop any extra values without a warning.\n* `merge`: only splits at most 'length(into)' times           # As seen below\n\n```{r}\ntibble(x = c(\"a,b,c\", \"d,e,f,g\", \"h,i,j\")) %>% \n  separate(x, c(\"one\", \"two\", \"three\"), extra = \"merge\")  # extra values not split, so “f,g” is in col \"three\" row 2\n```\n\n\n`fill` :  controls what happens when there are not enough pieces [as in 2nd dataset]. Three valid options :\n\n* `warn` (the default): emit a warning and fill from the right. # As seen above\n* `right`: fill with missing values on the right.\n* `left`: fill with missing values on the left                  # As seen below\n\n```{r}\ntibble(x = c(\"a,b,c\", \"d,e\", \"f,g,i\")) %>% \n  separate(x, c(\"one\", \"two\", \"three\"), fill = \"left\")    # col “one” has the <NA>, instead of col \"three\" (row 2)\n```\n\n-----------\n\nQ2. Both `unite()` and `separate()` have a `remove` argument. What does it do? Why would you set it to `FALSE`?\n\nA2.\n```{r}\n?unite        # \"If TRUE, remove input columns from output data frame\" -- Help\n?separate     # \"If TRUE, remove input column  from output data frame\" -- Help\n```\nYou would set it to `FALSE` if you want to **also** keep the old column(s)\n\n-----------\n\nQ3.\nCompare and contrast `separate()` and `extract()`.\nWhy are there three variations of separation (by position, by separator, and with groups), but only one unite?\n\nA3.\n```{r}\n?extract\n```\n\"Given a regular expression with capturing groups, `extract()` turns each group into a new column. If the groups don't match, or the input is `NA`, the output will be `NA`\" -- http://tidyr.tidyverse.org/reference/extract.html\n\n['Capturing group' : \"Parentheses group the regex between them. They capture the text matched by the regex inside them\"]\n\n* `separate()` : uses `sep` to split one column into many (multiple ways possible). (Default is that any non-alphanumeric character is a **separator**.) Else you can pass a vector of integers (interpreted as **positions** to split at), or pass a specific single character (a '**separator**', interpreted as a regular expression to split at).\n* `extract()` uses a regular expression to find **groups** and split one column into them/many (multiple ways possible).\n\nIf we're trying to `unite()` many specified columns into one, there is only one outcome and 'no variations' necessary/possible, (except choice of `sep`) -- based on https://jrnold.github.io/r4ds-exercise-solutions/tidy-data.html#separating-and-uniting\n\n\n-----------\n\n## 12. \"Tidy data\" [Chapter 9 hardcopy]\n### 12.5.1 Exercises\n\nQ1. Compare and contrast the `fill` arguments to `spread()` and `complete()`\n\nA1.\n```{r}\n?spread\n?complete\n```\n\n* `spread()` : `fill` sets **the** value. (\"missing values [both explicit & implicit] will be replaced with this value\" -- Help)\n* `complete()` : `fill` sets a value from a named list. (\"for each variable supplies a single value to use instead of `NA` for missing combinations\" -- Help) [implicit & explicit missing values]\n\n[PS. A value can be missing in one of two possible ways: Explicitly (ie. flagged with `NA`) or Implicitly (ie. simply not present in the data)]\n\n-----------\n\nQ2. What does the `direction` argument to `fill()` do? :\n\nA2.\n```{r}\n?fill\n```\n\n\"Direction in which to fill missing values. Currently either 'down' (the default) or 'up'\" -- Help\n...ie. Replace missing values with the most recent non-missing value (\"down\") or the next non-missing value (\"up\")\n\n\n-----------\n\n## 12. \"Tidy data\" [Chapter 9 hardcopy]\n### 12.6.1 Exercises\n\nQ1.\nIn this case study I set `na.rm = TRUE` just to make it easier to check that we had the correct values. Is this reasonable?\nThink about how missing values are represented in this dataset. Are there implicit missing values?\nWhat’s the difference between an `NA` and zero?\n\nA1.\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n-----------\n\nQ2.\nWhat happens if you neglect the `mutate()` step? (`mutate(key = stringr::str_replace(key, \"newrel\", \"new_rel\"))`)\n\nA2.\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n-----------\n\nQ3.\nI claimed that `iso2` and `iso3` were redundant with `country`. Confirm this claim\n\nA3.\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n-----------\n\nQ4.\nFor each `country`, `year`, and `sex` compute the total number of cases of TB. Make an informative visualisation of the data\n\nA4.\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n\n",
    "created" : 1517935906727.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "965339145",
    "id" : "B98F8303",
    "lastKnownWriteTime" : 1517939355,
    "last_content_update" : 1517939355144,
    "path" : "~/Dropbox/repos/R4DS_1217/R4DS_Chapter12.Rmd",
    "project_path" : "R4DS_Chapter12.Rmd",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_markdown"
}